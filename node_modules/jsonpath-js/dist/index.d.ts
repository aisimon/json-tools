// ============================================================================
// Primitive Types
// ============================================================================
type StringLiteral = string;
type Int = number;
type Number = number;
type True = boolean;
type False = boolean;
type Null = null;

// ============================================================================
// Literal Values
// ============================================================================
type Literal = {
	type: "Literal";
	member: Number | StringLiteral | True | False | Null;
};

// ============================================================================
// Selectors
// ============================================================================
type NameSelector = { type: "NameSelector"; member: StringLiteral };
type WildcardSelector = { type: "WildcardSelector" };
type IndexSelector = { type: "IndexSelector"; index: Int };
type SliceSelector = {
	type: "SliceSelector";
	start: Int | null;
	end: Int | null;
	step: Int | null;
};
type FilterSelector = { type: "FilterSelector"; expr: LogicalOrExpr };

type Selector =
	| NameSelector
	| WildcardSelector
	| SliceSelector
	| IndexSelector
	| FilterSelector;

type MemberNameShorthand = {
	type: "MemberNameShorthand";
	member: string;
};

// ============================================================================
// Segments
// ============================================================================
type BracketedSelection = Selector[];
type ChildSegement =
	| BracketedSelection
	| [WildcardSelector | MemberNameShorthand];
type DescendantSegment = {
	type: "DescendantSegment";
	selectors: BracketedSelection | (WildcardSelector | MemberNameShorthand)[];
};

type Segment = ChildSegement | DescendantSegment;

type NameSegment = [NameSelector] | [MemberNameShorthand];
type IndexSegment = [IndexSelector];
type SingularQuerySegments = (NameSegment | IndexSegment)[];

// ============================================================================
// Query Structure
// ============================================================================
type Root = {
	type: "Root";
	segments: Segment[];
};
type RelSingularQuery = {
	type: "CurrentNode";
	segments: SingularQuerySegments;
};
type AbsSingularQuery = Root;
type SingularQuery = RelSingularQuery | AbsSingularQuery;

type RelQuery = { type: "CurrentNode"; segments: Segment[] };
type FilterQuery = RelQuery | JsonpathQuery;

// Main JSONPath query type
type JsonpathQuery = Root;

// ============================================================================
// Function Extensions
// ============================================================================
type FunctionExpr = {
	type: "FunctionExpr";
	name: string;
	args: FunctionArgument[];
};
type FunctionArgument =
	| Literal
	| FilterQuery
	| FunctionExpr
	| LogicalOrExpr;

// ============================================================================
// Filter Expressions
// ============================================================================
interface LogicalOr {
	type: "LogicalBinary";
	operator: "||";
	left: FilterExpression;
	right: FilterExpression;
}
interface LogicalAnd {
	type: "LogicalBinary";
	operator: "&&";
	left: FilterExpression;
	right: FilterExpression;
}
interface LogicalNot {
	type: "LogicalUnary";
	operator: "!";
	expr: FilterExpression;
}

type LogicalUnary = LogicalNot;
type LogicalBinary = LogicalAnd | LogicalOr;
type LogicalExpression = LogicalBinary | LogicalUnary;

// Comparison Expressions
type Comparable = Literal | SingularQuery | FunctionExpr;
type ComparisonOp = "==" | "!=" | "<=" | ">=" | "<" | ">";
type ComparisonExpr = {
	type: "ComparisonExpr";
	left: Comparable;
	operator: ComparisonOp;
	right: Comparable;
};

// Test Expressions
type TestFilterExpr = {
	type: "TestExpr";
	query: FilterQuery | FunctionExpr;
};
type TestExpression = LogicalBinary | TestFilterExpr;
type TestExpr = TestExpression;

// Combined Filter Expression Types
type FilterExpression = LogicalExpression | ComparisonExpr | TestExpr;
type LogicalOrExpr = FilterExpression;

type JsonPrimitive = string | number | boolean | null;
type JsonObject = { [key: string]: JsonValue };
type JsonArray = JsonValue[];
type JsonValue = JsonPrimitive | JsonArray | JsonObject;
type Json = JsonValue;

type PathResult = {
    value: Json;
    path: string;
};
type PathSegmentsResult = {
    value: Json;
    segments: (string | number)[];
};
/**
 * A JSONPath query engine for executing JSONPath queries against JSON data.
 * Fully implements the RFC 9535 JSONPath specification.
 */
declare class JSONPathJS {
    #private;
    rootNode: JsonpathQuery;
    /**
     * Creates a new JSONPath query instance.
     * @param query - The JSONPath query string to parse
     * @throws Throws an error if the query string is invalid
     */
    constructor(query: string);
    /**
     * Executes the JSONPath query and returns only the matching values.
     * @param json - The JSON data to query against
     * @returns An array of matching values
     */
    find(json: Json): Json;
    /**
     * Executes the JSONPath query and returns both matching values and their JSONPath strings.
     * @param json - The JSON data to query against
     * @returns An array of objects containing the matching value and its JSONPath string
     */
    paths(json: Json): PathResult[];
    /**
     * Executes the JSONPath query and returns both matching values and their path segments as arrays.
     * Path segments are returned as arrays containing strings (for object keys) and numbers (for array indices).
     * The root segment $ is not included in path segments.
     * @param json - The JSON data to query against
     * @returns An array of objects containing the matching value and its path segments as an array
     */
    pathSegments(json: Json): PathSegmentsResult[];
}

export { JSONPathJS };
